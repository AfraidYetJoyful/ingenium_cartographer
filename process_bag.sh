#!/bin/bash

# Get bag file from args
cwd=$(pwd)
file=$(realpath "$1")
if [ "$2" = "-v" ]; then ### check for the visualize flag in the command path and set a control variable for it.
  visualize=true
else
  visualize=false
fi
if [ ! -f "$file" ]; then ### If parameter 1 is not a file, exit the process
  echo "$file is not a file."
  return 1
fi
if [ ! "${file##*.}" = "bag" ]; then ### If parameter 1 does not have a .bag extension, exit the process.
  echo "$file is not a bag file"
  return 1
fi

# Move to catkin workspace ### If the script cannot do so, exit the process
cd ~/catkin_ws/ || exit 
# Run ros setup
source /opt/ros/noetic/setup.bash
# Run cartographer setup
source install_isolated/setup.bash

### These next few lines copy a bunch of configuration files into a different directory. I'm not sure why, nor why they're using logic here rather than explicitly stating the file names they want moved where.
config_files=("slam.launch" "slam.lua" "localization.launch" "localization.lua" "lidar_stick.urdf" "slam_visualize.launch")
for config_file in "${config_files[@]}"; do
  directory="${config_file##*.}"
  if [ "$directory" == "lua" ]; then
    directory="configuration_files"
  fi
  cp "$HOME/ingenium_cartographer/cartographer_config/$config_file" "install_isolated/share/cartographer_ros/$directory/ingenium_$config_file" 
done

# Check if bag contains point or packets, if packets forcefully convert
### The section "$(rosbag info "$file")" calls a the info function on the bag file from parameter one. This returns a data set, which appears to be optimized for human readability, which explains the presence of the RegEx
### =~ is a regular expression (RegEx) operator. 
### \ is the RegEx escape character. \/velodyne_points therefore matches if the string "/velodyne points" is found. The next unit of "\ *" allows there to be any number of spaces after "/velodyne points". After these spaces, there may be any numbero of numbers, as dictated by "[0-9]*". Finally, there must be a space followed by the string "msgs", as indicated by "\ msgs". If all of these criterion are met, the regular expression matches and returns "true"
### Finally, the RegEx boolean value is inverted. So, if within the output of rosbag info there is not a string that looks like "/velodyne_points   123456789 msgs" (with any number of spaces after the text and any number of numbers), the code within the if statement will execute. 
### All of this serves to indicate whether the "info" file of the .bag contains points generated by a velodyne sensor.
if ! [[ $(rosbag info "$file") =~ \/velodyne_points\ *[0-9]*\ msgs ]]; then
  echo "Bag does not contain pointcloud, forcefully converting"
  new_file="${file%.*}_pointcloud.bag" ### If the above RegEx does not match, take the variable file. Check for all .s in the file, and cut the filepath to only keep the parts of the path to the left of the . which has the fewest characters to its right. [Essentially, this removes the file extension]. Then add the string "_pointcloud.bag" to the end of it, and create a new variable based on this new path.
  $(find . -name inquisitor) "$file" "$new_file" ### $(command) replaces the expression command with its output in the terminal. the "find . -name inquistor" command finds and outputs a file path according to the following parameters: "." tells it to look in the current directory only, and "-name inquisitor" tells it to find files with the name inquisitor. When it outputs the file path, it outputs it as something that looks like ./inquisitor, since it refers to file inquisitor in the current directory ("."). However. ./ is _also_ the syntax used to execute a command, so when it is fed straight to shell, the end result is to execute as a program any file in the current directory with "inquisitor" in the title, with the two paremeters of "$file" and "$new_file"
  file="$new_file" ### Replace the original file path with the new version, which presumably links to a file which has been edited by the inquisitor script.
fi

filename="$(basename -- "$file" .bag)" ### Edit the variable file name to the output of the command basename. basename interprets -- to mean that there are no further arguments after it, only a file path. Then it removes all directory path information and also the .bag extension.
# Validate bag
cartographer_rosbag_validate -bag_filename "$file"
# Remove old .pbstream file ### Make sure there are no conflicts--that there are not multiple .pbstream files with the same name. If there are, delete them. Future dev note: we probably won't have .pbstream files anymore since we're not using Google Cartographer, but if we have something similar we should be careful to delete them as soon as we can within the processing script.
if [ -f "$file.pbstream" ]; then
  echo -e ".pbstream file already exists, will be deleted"
  rm "$file.pbstream"
fi
# Start slam
if $visualize; then
  roslaunch cartographer_ros ingenium_slam_visualize.launch bag_filename:="$file" urdf_filename:="~/ingenium_cartographer/cartographer_config/lidar_stick.urdf" &
else
  roslaunch cartographer_ros ingenium_slam.launch bag_filenames:="$file" urdf_filename:="~/ingenium_cartographer/cartographer_config/lidar_stick.urdf" &
fi
# Wait for slam to finish
while [ ! -f "$file.pbstream" ]; do ### ! means not, -f means "file exists", and then "$file.pbstream" checks for the existence of the new .pbstream file that will be generated and uses that to determine when the SLAM has finished running.
  sleep 5
done

roslaunch cartographer_ros ingenium_localization.launch pose_graph_filename:="$file.pbstream" bag_filenames:="$file" ### Not at all sure what this line does. Note To Self: trace down the scripts and find out. >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

# Move back to old directory
cd "$(dirname "$file")" || exit

# Make directory for new files
output_dir="$filename"
if [ ! -d "$output_dir" ]; then
  mkdir "$output_dir"
fi

# Move files into new directory, and then move the .pbstream file and the original bag file back ### Why do this?
mv "$file"* "$output_dir"
cd "$output_dir" || exit
rm "$(basename "$file").pbstream" ### Delete the pbstream file, since it is specific to Google Cartographer* (*information from Johannes, late June 2025). Direct script modification by Abraham Baker. Previously, "rm" was "mv"
mv "$(basename "$file")" "$(dirname "$file")"

# Save a small copy of pointcloud
CloudCompare -SILENT -C_EXPORT_FMT PLY -O "$filename.bag_point_cloud.ply" -SS RANDOM 5000000 ### This line saves a random sampling of our pointcloud at a size of 5,000,000 points. If we can do without this with our new hardware, we should. Perhaps we should consider an algorithm to chop out big things like trees automatically to see if we can reduce file size that way, before we discard a bunch of data arbitrarily. 

# Return to original directory
cd "$cwd" || exit ### If original directory no longer exists, just exit the proccess. 

echo "Bag fully processed, press any key to exit"
read -r ### Pause until reading any character. Once a character is read, progress to the next line (that is, terminate the program).

